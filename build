#!/usr/bin/env ruby

require 'open-uri'
require 'open3'
require 'yaml'
require 'fileutils'

Dir.chdir(__dir__)

PACKAGES = YAML.load_stream(File.read('packages.yaml'))

BASE_URL = 'https://raw.githubusercontent.com/github/linguist/master'

DIRS = {
  default: %w(syntax indent compiler autoload ftplugin ctags after/syntax after/indent after/ftplugin),
  all: %w(syntax indent compiler autoload ftplugin after extras ctags),
  basic: %w(syntax compiler indent after/syntax after/indent),
  syntax: %w(syntax indent after/syntax after/indent),
  noafter: %w(syntax compiler indent autoload ftplugin),
  javascript: %w(syntax indent compiler autoload ftplugin ctags after/syntax after/indent after/ftplugin extras),
  go: %w(autoload/go/config.vim syntax compiler indent after/syntax after/indent)
}

def parallel(*procs)
  threads = procs.map { |p| Thread.new { method(p).call } }
  threads.map(&:join).map(&:value)
end

def read_strings(data, keys, print=false)
  if data.is_a?(Hash)
    data.flat_map do |key, val|
      read_strings(val, keys, keys.include?(key))
    end
  elsif data.is_a?(Array)
    data.flat_map { |d| read_strings(d, keys, print) }
  elsif data.is_a?(String)
    print ? [data] : []
  else
    []
  end
end

def transform_with(data, keys, transfrom=false, &block)
  if data.is_a?(Hash)
    Hash[data.map do |key, val|
      [key, transform_with(val, keys, keys.include?(key), &block)]
    end]
  elsif data.is_a?(Array)
    data.map { |d| transform_with(d, keys, transfrom, &block) }
  elsif data.is_a?(String)
    transfrom ? yield(data) : data
  else
    data
  end
end

def each_hash(data, &block)
  if data.is_a?(Hash)
    yield data
    data.each do |key, val|
      each_hash(val, &block)
    end
  elsif data.is_a?(Array)
    data.map { |d| each_hash(d, &block) }
  end
end

def patterns_to_vim_patterns(patterns)
  stdin, stdout, stderr = Open3.popen3('vim', '-V', '--clean', '/dev/stdin', '-es', '-c', "echo expand('%:p:h') | source #{__dir__}/eregex.vim", '-c', "for line in range(0, line('$')) | call setline(line, ExtendedRegex2VimRegex(getline(line))) | endfor", '-c', ':wq! /dev/stdout', chdir: __dir__)
  stdin.write(patterns.join("\n"))
  stdin.close
  stdout.readlines
end

def transform_patterns(data)
  patterns = read_strings(data, ["pattern", "patterns"])
  patterns_mapping = Hash[patterns.zip(patterns_to_vim_patterns(patterns))]
  transform_with(data, ["pattern", "patterns"]) { |a| patterns_mapping[a] }
end

def load_heuristics
  url = "#{BASE_URL}/lib/linguist/heuristics.yml"
  data = URI.open(url) { |io| YAML.load(io.read) }
  each_hash(data["disambiguations"]) do |h|
    if h.has_key?("named_pattern")
      h["pattern"] = data["named_patterns"].fetch(h["named_pattern"])
      h.delete("named_pattern")
    end
  end
  transform_patterns(data["disambiguations"])
end

def load_languages
  url = "#{BASE_URL}/lib/linguist/languages.yml"
  data = URI.open(url) { |io| YAML.load(io.read) }
end

# heuristics, languages = parallel(:load_heuristics, :load_languages)

def parse_remote(remote)
  match = remote.match(/(?<repo>[^@:]+)(?:@(?<branch>[^:]+))?(?::(?<path>.*))?/)
  [match[:repo], match[:branch] || "master", match[:path]]
end

def copy_file(package, src, dest)
  return unless [".vim", ".ctags", ".vital"].include?(File.extname(src))
  FileUtils.mkdir_p(File.dirname(dest))
  name = package.fetch("name")

  open(src, "r") do |input|
    open(dest, "a+") do |output|
      if name == "jsx"
        output << "if !exists('g:polyglot_disabled') || !(index(g:polyglot_disabled, 'typescript') != -1 || index(g:polyglot_disabled, 'typescript') != -1 || index(g:polyglot_disabled, 'jsx') != -1)\n\n"
      else
        output << "if !exists('g:polyglot_disabled') || index(g:polyglot_disabled, '#{name}') == -1\n\n"
      end
      IO.copy_stream(input, output)
      output << "\nendif\n"
    end
  end
end

def download
  FileUtils.rm_rf('tmp')

  PACKAGES.map do |package|
    Thread.new do
      repo, branch, path = parse_remote(package.fetch("remote"))
      dir = "tmp/" + repo.split('/')[1]
      FileUtils.mkdir_p(dir)
      url = "https://codeload.github.com/#{repo}/tar.gz/#{branch}"
      `curl --silent -fL #{url} | tar -zx -C "#{dir}" --strip 1`
      progress
    end
  end.map(&:join)
end

$i = 0
LYRICS = "Never gonna give you up.  Never gonna let you down.  " +
         "Never gonna run around and desert you.  " +
         "Never gonna make you cry.  Never gonna say goodbye.  " +
         "Never gonna tell a lie and hurt you."

$mutex = Mutex.new
def progress
  $mutex.synchronize do
    $stdout.write(LYRICS[$i] || ".")
    $i += 1
  end
end

def extract
  FileUtils.rm_rf(DIRS[:all])

  output = []
  PACKAGES.map do |package|
    repo, branch, path = parse_remote(package["remote"])
    dir = "tmp/" + repo.split('/')[1]
    subdirs = []
    for subdir in DIRS.fetch(package.fetch("dirs", "default").to_sym)
      subtree = "#{dir}/#{path ? path + "/" : ""}"
      subpath = "#{subtree}#{subdir}"
      if FileTest.directory?(subpath)
        Dir.glob("#{subdir}/**/*", base: subtree).each do |p|
          next unless File.file?("#{subtree}/#{p}")
          copy_file(package, "#{subtree}/#{p}", p)
        end

        subdirs << subdir.split("/").last
      elsif File.exist?(subpath)
        copy_file(package, subpath, subdir)
      end
    end

    output << "- [#{package["name"]}](https://github.com/#{repo}) (#{subdirs.uniq.join(", ")})"
    progress
  end

  readme = File.read('README.md')

  readme.gsub!(
    %r{(?<=<!--Package Count-->).*?(?=<!--/Package Count-->)},
    output.size.to_s
  )

  readme.gsub!(
    %r{(?<=<!--Language Packs-->).*?(?=<!--/Language Packs-->)}m,
    "\n" + output.sort.join("\n") + "\n"
  )

  File.write('README.md', readme)
end

download
extract
puts(" Bye! Have a wonderful time!")
FileUtils.rm_rf("tmp")
